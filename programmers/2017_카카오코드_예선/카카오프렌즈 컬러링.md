 ## ğŸ”¥ ë‚œì´ë„
`Level2`

## ğŸ“ ë¬¸ì œì„¤ëª…
ì¶œíŒì‚¬ì˜ í¸ì§‘ìì¸ ì–´í”¼ì¹˜ëŠ” ë„¤ì˜¤ì—ê²Œ ì»¬ëŸ¬ë§ë¶ì— ë“¤ì–´ê°ˆ ì›í™”ë¥¼ ê·¸ë ¤ë‹¬ë¼ê³  ë¶€íƒí•˜ì—¬ ì—¬ëŸ¬ ì¥ì˜ ê·¸ë¦¼ì„ ë°›ì•˜ë‹¤. ì—¬ëŸ¬ ì¥ì˜ ê·¸ë¦¼ì„ ë‚œì´ë„ ìˆœìœ¼ë¡œ ì»¬ëŸ¬ë§ë¶ì— ë„£ê³  ì‹¶ì—ˆë˜ ì–´í”¼ì¹˜ëŠ” ì˜ì—­ì´ ë§ìœ¼ë©´ ìƒ‰ì¹ í•˜ê¸°ê°€ ê¹Œë‹¤ë¡œì›Œ ì–´ë ¤ì›Œì§„ë‹¤ëŠ” ì‚¬ì‹¤ì„ ë°œê²¬í•˜ê³  ê·¸ë¦¼ì˜ ë‚œì´ë„ë¥¼ ì˜ì—­ì˜ ìˆ˜ë¡œ ì •ì˜í•˜ì˜€ë‹¤. (ì˜ì—­ì´ë€ ìƒí•˜ì¢Œìš°ë¡œ ì—°ê²°ëœ ê°™ì€ ìƒ‰ìƒì˜ ê³µê°„ì„ ì˜ë¯¸í•œë‹¤.)

ê·¸ë¦¼ì— ëª‡ ê°œì˜ ì˜ì—­ì´ ìˆëŠ”ì§€ì™€ ê°€ì¥ í° ì˜ì—­ì˜ ë„“ì´ëŠ” ì–¼ë§ˆì¸ì§€ ê³„ì‚°í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•´ë³´ì.
![](http://t1.kakaocdn.net/codefestival/apeach.png)

ìœ„ì˜ ê·¸ë¦¼ì€ ì´ 12ê°œ ì˜ì—­ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆìœ¼ë©°, ê°€ì¥ ë„“ì€ ì˜ì—­ì€ ì–´í”¼ì¹˜ì˜ ì–¼êµ´ë©´ìœ¼ë¡œ ë„“ì´ëŠ” 120ì´ë‹¤.

## âŒ›ï¸ ì œí•œ ì¡°ê±´
### ì…ë ¥ í˜•ì‹
ì…ë ¥ì€ ê·¸ë¦¼ì˜ í¬ê¸°ë¥¼ ë‚˜íƒ€ë‚´ëŠ” `m`ê³¼ `n`, ê·¸ë¦¬ê³  ê·¸ë¦¼ì„ ë‚˜íƒ€ë‚´ëŠ” `m Ã— n` í¬ê¸°ì˜ 2ì°¨ì› ë°°ì—´ `picture`ë¡œ ì£¼ì–´ì§„ë‹¤. ì œí•œì¡°ê±´ì€ ì•„ë˜ì™€ ê°™ë‹¤.
- `1 <= m, n <= 100`
- `picture`ì˜ ì›ì†ŒëŠ” `0` ì´ìƒ `2^31 - 1` ì´í•˜ì˜ ì„ì˜ì˜ ê°’ì´ë‹¤.
- `picture`ì˜ ì›ì†Œ ì¤‘ ê°’ì´ `0`ì¸ ê²½ìš°ëŠ” ìƒ‰ì¹ í•˜ì§€ ì•ŠëŠ” ì˜ì—­ì„ ëœ»í•œë‹¤.

### ì¶œë ¥ í˜•ì‹
ë¦¬í„´ íƒ€ì…ì€ ì›ì†Œê°€ ë‘ ê°œì¸ ì •ìˆ˜ ë°°ì—´ì´ë‹¤. ê·¸ë¦¼ì— ëª‡ ê°œì˜ ì˜ì—­ì´ ìˆëŠ”ì§€ì™€ ê°€ì¥ í° ì˜ì—­ì€ ëª‡ ì¹¸ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆëŠ”ì§€ë¥¼ ë¦¬í„´í•œë‹¤.

## ğŸ–¨  ì…ì¶œë ¥ ì˜ˆ
m|	n|	picture|	answer
--|--|--|--
6|	4|	[[1, 1, 1, 0], [1, 2, 2, 0], [1, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 3], [0, 0, 0, 3]]|	[4, 5]

## âœğŸ» í’€ì´ ë° ë¶„ë¥˜
- `DFS`, `BFS`, `ê·¸ë˜í”„ íƒìƒ‰`

ì „í˜•ì ì¸ `BFS`, `DFS`ë¬¸ì œì´ë‹¤. ë‚˜ëŠ” `BFS`ë¡œ ë¬¸ì œë¥¼ í•´ê²°í–ˆë‹¤.

ì´ ë¬¸ì œì—ì„œ ì£¼ì˜í•  ì ì€ ì „ì—­ìœ¼ë¡œ ì„ ì–¸í•˜ê³  `solution` í•¨ìˆ˜ì—ì„œ ì´ˆê¸°í™”í•˜ë©´ í‹€ë ¸ë‹¤ê³  ë‚˜ì˜¨ë‹¤.

2ì¤‘ for ë¬¸ì„ ì‚¬ìš©í•˜ì—¬ 0ì´ ì•„ë‹Œ ìˆ˜ì™€ ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´ ì˜ì—­ì˜ ìˆ˜ë¥¼ 1 ë”í•´ì¤€ë‹¤. 
ê·¸ë¦¬ê³  `bfs`í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ íƒìƒ‰ì„ í•˜ë©´ì„œ ê·¸ ì˜ì—­ì˜ ìˆ˜ë¥¼ ì¹´ìš´íŠ¸í•˜ê³  íƒìƒ‰ì´ ëë‚˜ë©´ `max_size_of_one_area`ì™€ `cnt` ë‘˜ ì¤‘ í° ê°’ì„ ë„£ì–´ì¤€ë‹¤.

## ğŸ’» í’€ì´ ì½”ë“œ
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef pair<int, int> pii;

const int dy[] = {-1, 1, 0, 0};
const int dx[] = {0, 0, -1, 1};

void bfs(vector<vector<int>> picture, vector<vector<bool> > &visited, int &max_size_of_one_area, pii s, int m, int n, int num) {
    queue<pii> q;
    int cnt = 0;
    q.push(s);
    
    while (!q.empty()) {
        int y = q.front().first;
        int x = q.front().second;
        q.pop();
        
        for (int i = 0; i < 4; i++) {
            int ny = y + dy[i];
            int nx = x + dx[i];
            if (-1 < ny && ny < m && -1 < nx && nx < n && picture[ny][nx] == num) {
                if (!visited[ny][nx]) {
                    visited[ny][nx] = true;
                    q.push({ny, nx});
                    cnt += 1;
                }
            }
        }
    }
    max_size_of_one_area = max(max_size_of_one_area, cnt + 1);
}

vector<int> solution(int m, int n, vector<vector<int>> picture) {
    int number_of_area = 0;
    int max_size_of_one_area = 0;
    vector<vector<bool> > visited(m, vector<bool>(n, false));
    
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (!visited[i][j] && picture[i][j] != 0) {
                visited[i][j] = true;
                number_of_area += 1;
                bfs(picture, visited, max_size_of_one_area, {i, j}, m, n, picture[i][j]);
            }
        }
    }
    
    vector<int> answer(2);
    answer[0] = number_of_area;
    answer[1] = max_size_of_one_area;
    return answer;
}
```