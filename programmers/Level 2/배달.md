## ë¬¸ì œ ì„¤ëª…

Nê°œì˜ ë§ˆì„ë¡œ ì´ë£¨ì–´ì§„ ë‚˜ë¼ê°€ ìˆìŠµë‹ˆë‹¤. ì´ ë‚˜ë¼ì˜ ê° ë§ˆì„ì—ëŠ” 1ë¶€í„° Nê¹Œì§€ì˜ ë²ˆí˜¸ê°€ ê°ê° í•˜ë‚˜ì”© ë¶€ì—¬ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ê° ë§ˆì„ì€ ì–‘ë°©í–¥ìœ¼ë¡œ í†µí–‰í•  ìˆ˜ ìˆëŠ” ë„ë¡œë¡œ ì—°ê²°ë˜ì–´ ìˆëŠ”ë°, ì„œë¡œ ë‹¤ë¥¸ ë§ˆì„ ê°„ì— ì´ë™í•  ë•ŒëŠ” ì´ ë„ë¡œë¥¼ ì§€ë‚˜ì•¼ í•©ë‹ˆë‹¤. ë„ë¡œë¥¼ ì§€ë‚  ë•Œ ê±¸ë¦¬ëŠ” ì‹œê°„ì€ ë„ë¡œë³„ë¡œ ë‹¤ë¦…ë‹ˆë‹¤. í˜„ì¬ 1ë²ˆ ë§ˆì„ì— ìˆëŠ” ìŒì‹ì ì—ì„œ ê° ë§ˆì„ë¡œ ìŒì‹ ë°°ë‹¬ì„ í•˜ë ¤ê³  í•©ë‹ˆë‹¤. ê° ë§ˆì„ë¡œë¶€í„° ìŒì‹ ì£¼ë¬¸ì„ ë°›ìœ¼ë ¤ê³  í•˜ëŠ”ë°, Nê°œì˜ ë§ˆì„ ì¤‘ì—ì„œ K ì‹œê°„ ì´í•˜ë¡œ ë°°ë‹¬ì´ ê°€ëŠ¥í•œ ë§ˆì„ì—ì„œë§Œ ì£¼ë¬¸ì„ ë°›ìœ¼ë ¤ê³  í•©ë‹ˆë‹¤. ë‹¤ìŒì€ N = 5, K = 3ì¸ ê²½ìš°ì˜ ì˜ˆì‹œì…ë‹ˆë‹¤.

![](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d7779d88-084c-4ffa-ae9f-2a42f97d3bbf/%E1%84%87%E1%85%A2%E1%84%83%E1%85%A1%E1%86%AF_1_uxun8t.png)

ìœ„ ê·¸ë¦¼ì—ì„œ 1ë²ˆ ë§ˆì„ì— ìˆëŠ” ìŒì‹ì ì€ [1, 2, 4, 5] ë²ˆ ë§ˆì„ê¹Œì§€ëŠ” 3 ì´í•˜ì˜ ì‹œê°„ì— ë°°ë‹¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ 3ë²ˆ ë§ˆì„ê¹Œì§€ëŠ” 3ì‹œê°„ ì´ë‚´ë¡œ ë°°ë‹¬í•  ìˆ˜ ìˆëŠ” ê²½ë¡œê°€ ì—†ìœ¼ë¯€ë¡œ 3ë²ˆ ë§ˆì„ì—ì„œëŠ” ì£¼ë¬¸ì„ ë°›ì§€ ì•ŠìŠµë‹ˆë‹¤. ë”°ë¼ì„œ 1ë²ˆ ë§ˆì„ì— ìˆëŠ” ìŒì‹ì ì´ ë°°ë‹¬ ì£¼ë¬¸ì„ ë°›ì„ ìˆ˜ ìˆëŠ” ë§ˆì„ì€ 4ê°œê°€ ë©ë‹ˆë‹¤.   
ë§ˆì„ì˜ ê°œìˆ˜ N, ê° ë§ˆì„ì„ ì—°ê²°í•˜ëŠ” ë„ë¡œì˜ ì •ë³´ road, ìŒì‹ ë°°ë‹¬ì´ ê°€ëŠ¥í•œ ì‹œê°„ Kê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, ìŒì‹ ì£¼ë¬¸ì„ ë°›ì„ ìˆ˜ ìˆëŠ” ë§ˆì„ì˜ ê°œìˆ˜ë¥¼ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.

## ì œí•œì‚¬í•­
- ë§ˆì„ì˜ ê°œìˆ˜ Nì€ 1 ì´ìƒ 50 ì´í•˜ì˜ ìì—°ìˆ˜ì…ë‹ˆë‹¤.
- roadì˜ ê¸¸ì´(ë„ë¡œ ì •ë³´ì˜ ê°œìˆ˜)ëŠ” 1 ì´ìƒ 2,000 ì´í•˜ì…ë‹ˆë‹¤.
- roadì˜ ê° ì›ì†ŒëŠ” ë§ˆì„ì„ ì—°ê²°í•˜ê³  ìˆëŠ” ê° ë„ë¡œì˜ ì •ë³´ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
- roadëŠ” ê¸¸ì´ê°€ 3ì¸ ë°°ì—´ì´ë©°, ìˆœì„œëŒ€ë¡œ (a, b, c)ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
  - a, b(1 â‰¤ a, b â‰¤ N, a != b)ëŠ” ë„ë¡œê°€ ì—°ê²°í•˜ëŠ” ë‘ ë§ˆì„ì˜ ë²ˆí˜¸ì´ë©°, c(1 â‰¤ c â‰¤ 10,000, cëŠ” ìì—°ìˆ˜)ëŠ” ë„ë¡œë¥¼ ì§€ë‚˜ëŠ”ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì…ë‹ˆë‹¤.
  - ë‘ ë§ˆì„ a, bë¥¼ ì—°ê²°í•˜ëŠ” ë„ë¡œëŠ” ì—¬ëŸ¬ ê°œê°€ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  - í•œ ë„ë¡œì˜ ì •ë³´ê°€ ì—¬ëŸ¬ ë²ˆ ì¤‘ë³µí•´ì„œ ì£¼ì–´ì§€ì§€ ì•ŠìŠµë‹ˆë‹¤.
- KëŠ” ìŒì‹ ë°°ë‹¬ì´ ê°€ëŠ¥í•œ ì‹œê°„ì„ ë‚˜íƒ€ë‚´ë©°, 1 ì´ìƒ 500,000 ì´í•˜ì…ë‹ˆë‹¤.
- ì„ì˜ì˜ ë‘ ë§ˆì„ê°„ì— í•­ìƒ ì´ë™ ê°€ëŠ¥í•œ ê²½ë¡œê°€ ì¡´ì¬í•©ë‹ˆë‹¤.
- 1ë²ˆ ë§ˆì„ì— ìˆëŠ” ìŒì‹ì ì´ K ì´í•˜ì˜ ì‹œê°„ì— ë°°ë‹¬ì´ ê°€ëŠ¥í•œ ë§ˆì„ì˜ ê°œìˆ˜ë¥¼ return í•˜ë©´ ë©ë‹ˆë‹¤.

## ì…ì¶œë ¥ ì˜ˆ
N|	road|	K|	result
--|--|--|--
5|	[[1,2,1],[2,3,3],[5,2,2],[1,4,2],[5,3,1],[5,4,2]]|	3|	4
6|	[[1,2,1],[1,3,2],[2,3,2],[3,4,3],[3,5,2],[3,5,3],[5,6,1]]|	4	|4

## ğŸ“‚ ë¶„ë¥˜
`ê·¸ë˜í”„` `ë‹¤ìµìŠ¤íŠ¸ë¼`

## ğŸ’¡ í’€ì´
1ë²ˆ ë§ˆì„ì—ì„œ ê° ë§ˆì„ ê°„ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œê¸° ë•Œë¬¸ì— ë‹¤ìµìŠ¤íŠ¸ë¼ë¥¼ ì´ìš©í•´ì•¼ í•œë‹¤.

ìš°ì„  ì£¼ì–´ì§„ `road` ë§¤ê°œë³€ìˆ˜ë¡œ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ì–´ì•¼ í•œë‹¤.   
ê·¸ë‹¤ìŒ `distance` ë°°ì—´ì„ ë§Œë“¤ì–´ ì‹œì‘ ë§ˆì„ì¸ 1ë²ˆ ë§ˆì„ì„ ì œì™¸í•˜ê³  `Integer.MAX_VALUE`ë¡œ ì´ˆê¸°í™” ì‹œì¼œì¤€ë‹¤.   
> 1ë²ˆ ë§ˆì„ì„ ì œì™¸í•˜ëŠ” ê²½ìš°ëŠ” 1ë²ˆ ë§ˆì„ì—ì„œ ì‹œì‘í•˜ê¸° ë•Œë¬¸ì´ë‹¤.   
> ë§Œì•½ 2ë²ˆ ë§ˆì„ì—ì„œ ì‹œì‘í•˜ë©´ 2ë²ˆì„ ì œì™¸í•˜ê³  ì´ˆê¸°í™” ì‹œì¼œì¤€ë‹¤.

ê·¸ë¦¬ê³  ë‹¤ìµìŠ¤íŠ¸ë¼ë¥¼ ì‚¬ìš©í•´ì„œ ê° ë§ˆì„ ë‹¹ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•˜ê³  `K`ê°’ ì´í•˜ì¸ ë§ˆì„ ê°œìˆ˜ë¥¼ return í•˜ë©´ ëœë‹¤.

## ğŸ’» ì½”ë“œ
```java
import java.util.*;

class Solution {
    private static ArrayList<Edge>[] adj;
    private static int[] distance;

    private static class Edge implements Comparable<Edge> {
        int v;
        int w;
        public Edge(int v, int w) {
            this.v = v;
            this.w = w;
        }

        @Override
        public int compareTo(Edge o) {
            return w - o.w;
        }
    }

    public int solution(int N, int[][] road, int K) {
        int answer = 0;

        initialize(road, N);
        delivery();

        for (int n : distance) {
            if (n <= K) {
                answer += 1;
            }
        }

        return answer;
    }

    private void initialize(int[][] road, int N)  {
        adj = new ArrayList[N + 1];
        distance = new int[N + 1];
        
        for (int i = 1; i <= N; i++) adj[i] = new ArrayList<>();
        
        for (int[] r : road) {
            int u = r[0], v = r[1], edge = r[2];
            adj[u].add(new Edge(v, edge));
            adj[v].add(new Edge(u, edge));
        }

        for (int i = 0; i <= N; i++) {
            distance[i] = Integer.MAX_VALUE;
        }
        distance[1] = 0;
    }

    private void delivery() {
        PriorityQueue<Edge> pq = new PriorityQueue<>();
        pq.add(new Edge(1, 0));

        while (!pq.isEmpty()) {
            Edge cur = pq.poll();
            int vertex = cur.v;
            int weight = cur.w;

            if (distance[vertex] >= weight) {
                for (Edge e : adj[vertex]) {
                    int nextVertex = e.v;
                    int nextWeight = e.w + weight;
                    if (distance[nextVertex] > nextWeight) {
                        distance[nextVertex] = nextWeight;
                        pq.add(new Edge(nextVertex, nextWeight));
                    }
                }
            }
        }
    }
}
```